<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-07-09T15:59:56+08:00</updated><id>/feed.xml</id><title type="html">我的博客</title><entry><title type="html">Python</title><link href="/Python/" rel="alternate" type="text/html" title="Python" /><published>2021-06-04T00:00:00+08:00</published><updated>2021-06-04T00:00:00+08:00</updated><id>/Python</id><content type="html" xml:base="/Python/">&lt;h1 id=&quot;python-性能问题&quot;&gt;python 性能问题&lt;/h1&gt;
&lt;h2 id=&quot;字典列表元组初始化用----还是-dict-list-tuple&quot;&gt;字典、列表、元组初始化用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{} [] ()&lt;/code&gt; 还是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dict() list() tuple()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import timeit
print(timeit.timeit(stmt='{}', number=10000000))
print(timeit.timeit(stmt='dict()', number=10000000))

输出：
0.1654788
0.83084
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import timeit
print(timeit.timeit(stmt='[]', number=10000000))
print(timeit.timeit(stmt='list()', number=10000000))

输出：
0.1816867
0.8409157
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import timeit
print(timeit.timeit(stmt='()', number=10000000))
print(timeit.timeit(stmt='tuple()', number=10000000))

输出：
0.1089527
0.5617243
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;python-语法&quot;&gt;Python 语法&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;字典直接根据下标取值，如果下标对应的值不存在，会报错（和C++不同）&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wangbin</name></author><category term="编程语言" /><category term="Python" /><summary type="html">python 性能问题 字典、列表、元组初始化用 {} [] () 还是 dict() list() tuple() ``` import timeit print(timeit.timeit(stmt=’{}’, number=10000000)) print(timeit.timeit(stmt=’dict()’, number=10000000))</summary></entry><entry><title type="html">Golang</title><link href="/Golang/" rel="alternate" type="text/html" title="Golang" /><published>2021-04-11T00:00:00+08:00</published><updated>2021-04-11T00:00:00+08:00</updated><id>/Golang</id><content type="html" xml:base="/Golang/">&lt;h1 id=&quot;1go-语言简介&quot;&gt;1、Go 语言简介&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Go 语言起源 2007 年，并于 2009 年正式对外发布&lt;/li&gt;
  &lt;li&gt;Go 语言三位作者：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Robert Griesemer&lt;/code&gt;，参与开发 Java HotSpot 虚拟机；&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rob Pike&lt;/code&gt;，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ken Thompson&lt;/code&gt;，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为什么要创造一门编程语言：
    &lt;ul&gt;
      &lt;li&gt;C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。&lt;/li&gt;
      &lt;li&gt;相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。&lt;/li&gt;
      &lt;li&gt;在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：==快速编译，高效执行，易于开发==。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hello World&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Go 程序都组织成包&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// import 语句用于导入外部代码。标准库中的 fmt 包用于格式化并输出数据&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 像 C 语言一样，main 函数是程序执行的入口&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2基本结构与数据类型&quot;&gt;2、基本结构与数据类型&lt;/h1&gt;
&lt;h2 id=&quot;21-文件名关键字标识符&quot;&gt;2.1 文件名、关键字、标识符&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;文件后缀名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.go&lt;/code&gt;，由小写字母组成，如果有多个部分，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 分隔，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fmt_test.go&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;go语言关键字只有25个：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;还有 36 个预定义标识符：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;append, bool, byte, cap, close, complex, complex64, complex128, uint16, copy, false, float32, float64, imag, int, int8, int16, uint32, int32, int64, iota, len, make, new, nil, panic, uint64, print, println, real, recover, string, true, uint, uint8, uintptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X56&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_x23&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;өԑ12&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-包的概念导入与可见性&quot;&gt;2.2 包的概念、导入与可见性&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。&lt;/li&gt;
  &lt;li&gt;必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。&lt;/li&gt;
  &lt;li&gt;如果对一个包进行更改或重新编译，所有引用了这个包的程序都必须全部重新编译。&lt;/li&gt;
  &lt;li&gt;导入包的方式：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;os&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;&quot;os&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可见性规则：
    &lt;ul&gt;
      &lt;li&gt;当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）&lt;/li&gt;
      &lt;li&gt;标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可以通过使用包的别名来解决包名之间的名称冲突，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import fm &quot;fmt&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果导入了一个包却没有使用它，则在编译时会报错，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;os&quot; imported but not used&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;23-注释&quot;&gt;2.3 注释&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;使用和 C 语言一样的注释方式，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//&lt;/code&gt; 表示单行注释，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/**/&lt;/code&gt; 表示多行注释或块注释&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-类型与运算符&quot;&gt;2.4 类型与运算符&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Go 语言类型包括：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int、float32、 float64、bool、string、struct、array、slice、map、channel、interface。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;与操作系统架构无关的类型都有固定的大小&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;并在类型的名称中就可以看出来&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;整数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;127&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int16&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;32768&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32767&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;147&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;483&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;648&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;147&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;483&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;647&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;223&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;372&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;854&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;775&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;808&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;223&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;372&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;036&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;854&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;775&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;807&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;无符号整数&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint16&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;535&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;294&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;967&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;295&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;446&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;744&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;073&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;709&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;551&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;615&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;浮点型&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IEEE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;754&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;标准&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）：&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e-45&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e38&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e-324&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;107&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e308&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;位运算：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;、|、^、&amp;amp;^(位清除：将指定位置上的值设置为 0)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;一元运算符：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;、&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;逻辑运算符：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==、!=、&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;算术运算符：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+、-、*、/、%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;优先级     运算符
 7         ^ !
 6         * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^
 5         + - | ^
 4         == != &amp;lt; &amp;lt;= &amp;gt;= &amp;gt;
 3         &amp;lt;-
 2         &amp;amp;&amp;amp;
 1         ||
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;类型别名：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type newType orgType&lt;/code&gt;，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type AGE int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3变量常量指针&quot;&gt;3、变量、常量、指针&lt;/h1&gt;
&lt;h2 id=&quot;31-变量&quot;&gt;3.1 变量&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;声明变量的一般形式是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var&lt;/code&gt; 关键字：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var identifier type&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;为什么将变量类型放到变量名后面：避免像 C 语言中那样含糊不清的声明形式，例如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int* a, b&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;当一个变量被声明之后，系统自动赋予它该类型的零值：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 为 0，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 为 0.0，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool&lt;/code&gt; 为 false，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt; 为空字符串，指针为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Go 编译器可以根据变量的值来自动推断其类型，在编译时经完成推断过程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 在函数体内声明局部变量时，可使用简短声明语法 :=，不可以用于全局变量的声明与赋值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 同一类型的多个变量可以声明在同一行&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 多个变量使用 := 声明并初始化&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 交换2个变量的值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;值类型和引用类型：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;、数组、结构体属于值类型&lt;/li&gt;
      &lt;li&gt;指针、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slice&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;channel&lt;/code&gt; 属于引用类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;32-常量&quot;&gt;3.2 常量&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;常量使用关键字 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 定义，用于存储不会改变的数据。常量的定义格式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const identifier [type] = value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 显式类型定义&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// 隐式类型定义&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;常量还可以用作枚举：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unknown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Female&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Male&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iota&lt;/code&gt; 使用方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;// 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 并且没有赋值的常量默认会应用上一行的赋值表达式：&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// a = 0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// b = 1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// c = 2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// a = 0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// b = 1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// c = 2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;// d = 5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// e = 5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Banana&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Apple=1 Banana=2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Cherimoya&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Durian&lt;/span&gt;                  &lt;span class=&quot;c&quot;&gt;// Cherimoya=2 Durian=3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elderberry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fig&lt;/span&gt;                    &lt;span class=&quot;c&quot;&gt;// Elderberry=3, Fig=4&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;                       &lt;span class=&quot;c&quot;&gt;// 使用 _ 忽略不需要的 iota&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// 1 &amp;lt;&amp;lt; (10*1)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// 1 &amp;lt;&amp;lt; (10*2)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GB&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// 1 &amp;lt;&amp;lt; (10*3)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TB&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// 1 &amp;lt;&amp;lt; (10*4)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;4控制结构&quot;&gt;4、控制结构&lt;/h1&gt;
&lt;h2 id=&quot;41-if-else-结构&quot;&gt;4.1 if-else 结构&lt;/h2&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a &amp;gt; b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a &amp;lt; b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a == b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;if 和 else 之后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 必须和关键字同一行，否则编译会报错：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax error: unexpected newline, expecting { after if clause&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;42-switch结构&quot;&gt;4.2 switch结构&lt;/h2&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;// 第一种形式&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;case value1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;// 这里没有 break&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;case value2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 第二种形式，case 中进行条件判断&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 第三种形式，包含一个初始化语句&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;变量 variable 可以是任何类型，而 value1 和 value2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。&lt;/li&gt;
  &lt;li&gt;如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fallthrough&lt;/code&gt; 关键字来达到目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fallthrough&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 当 i == 0 时函数也会被调用&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;43-for-结构&quot;&gt;4.3 for 结构&lt;/h2&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;// 基本形式&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;This is the %d iteration&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 基于条件判断的迭代，类似于其他语言的 while&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The variable i is now: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 无限循环&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// do something&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// 需要退出循环，用 break&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// for-range 结构&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1、go基本语法，常用容器：数组，slice，map，（ 第2、4章和文档）&lt;/p&gt;</content><author><name>wangbin</name></author><category term="编程语言" /><category term="Golang" /><summary type="html">1、Go 语言简介 Go 语言起源 2007 年，并于 2009 年正式对外发布 Go 语言三位作者： Robert Griesemer，参与开发 Java HotSpot 虚拟机； Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言； Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范 为什么要创造一门编程语言： C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。 相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：==快速编译，高效执行，易于开发==。 Hello World</summary></entry><entry><title type="html">系统设计</title><link href="/SystemDesign/" rel="alternate" type="text/html" title="系统设计" /><published>2021-02-26T00:00:00+08:00</published><updated>2021-02-26T00:00:00+08:00</updated><id>/SystemDesign</id><content type="html" xml:base="/SystemDesign/">&lt;h2 id=&quot;1高并发&quot;&gt;1、高并发&lt;/h2&gt;

&lt;p&gt;https://snailclimb.gitee.io/javaguide/#/?id=%e9%ab%98%e5%b9%b6%e5%8f%91&lt;/p&gt;

&lt;h3 id=&quot;11负载均衡&quot;&gt;1.1、负载均衡&lt;/h3&gt;
&lt;p&gt;根据节点负载情况，将客户端请求发送到不同的节点。常用的负载均衡算法如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;轮询&lt;/li&gt;
  &lt;li&gt;加权轮询&lt;/li&gt;
  &lt;li&gt;最少连接数&lt;/li&gt;
  &lt;li&gt;随机&lt;/li&gt;
  &lt;li&gt;源地址哈希（IP Hash）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12缓存&quot;&gt;1.2、缓存&lt;/h3&gt;
&lt;p&gt;网站性能优化的第一定律：有限考虑使用缓存。&lt;/p&gt;

&lt;h3 id=&quot;13消息队列&quot;&gt;1.3、消息队列&lt;/h3&gt;

&lt;h4 id=&quot;131模型&quot;&gt;1.3.1、模型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;点对点模式：一个消息只能被一个消费者消费一次。&lt;/li&gt;
  &lt;li&gt;发布订阅模式：多个订阅者可以从频道订阅这条消息并消费。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;132使用场景&quot;&gt;1.3.2、使用场景&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;异步处理：例如用户注册发送奖励。&lt;/li&gt;
  &lt;li&gt;流量削锋：服务器根据处理能力从消息队列中获取消息处理。防止短时间内大量请求压垮服务器。&lt;/li&gt;
  &lt;li&gt;应用解藕：一个模块修改不影响其他模块，实现可扩展性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;133可靠性&quot;&gt;1.3.3、可靠性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;发送端可靠性：使用本地消息表，发送成功删除本地消息，失败继续发送。&lt;/li&gt;
  &lt;li&gt;接收端可靠性：消费端业务逻辑幂等性；消息具有唯一编号。并使用一张日志表记录已经消费的消息编号。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14读写分离分库分表&quot;&gt;1.4、读写分离、分库分表&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;读写分离可以大幅提高读性能，小幅提高写的性能&lt;/li&gt;
  &lt;li&gt;分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2高可用&quot;&gt;2、高可用&lt;/h2&gt;

&lt;p&gt;https://snailclimb.gitee.io/javaguide/#/?id=%e9%ab%98%e5%8f%af%e7%94%a8&lt;/p&gt;

&lt;h3 id=&quot;21-降级&quot;&gt;2.1 降级&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;服务降级是指系统为了应对大量的请求，主动关闭部分功能，以此释放服务器资源从而保证核心功能可用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-限流&quot;&gt;2.2 限流&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;限流(Ratelimiting)是指对服务的请求进行限制，例如某一接口的请求限制为 100 个每秒,对超过限制的请求则进行快速失败或丢弃。&lt;/li&gt;
  &lt;li&gt;常见限流算法（https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673）
    &lt;ul&gt;
      &lt;li&gt;漏桶算法&lt;/li&gt;
      &lt;li&gt;令牌桶算法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-熔断&quot;&gt;2.3 熔断&lt;/h3&gt;

&lt;h2 id=&quot;分布式id生成算法&quot;&gt;分布式id生成算法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;uuid&lt;/li&gt;
  &lt;li&gt;数据库自增id&lt;/li&gt;
  &lt;li&gt;snowflake：41bit时间戳 + 10bit机器id + 12bit序列号&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分布式系统如何保证一致性&quot;&gt;分布式系统如何保证一致性&lt;/h2&gt;

&lt;h2 id=&quot;reactor模式&quot;&gt;reactor模式&lt;/h2&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1488120&lt;/p&gt;

&lt;p&gt;无论是C++还是Java编写的网络框架，大多数都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I/O事件。&lt;/p&gt;

&lt;p&gt;Reactor模型中定义的三种角色：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。&lt;/li&gt;
  &lt;li&gt;Acceptor：处理客户端新连接，并分派请求到处理器链中。&lt;/li&gt;
  &lt;li&gt;Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;微博粉丝关系设计&quot;&gt;微博粉丝关系设计&lt;/h2&gt;</content><author><name>wangbin</name></author><category term="系统架构设计" /><summary type="html">1、高并发</summary></entry><entry><title type="html">C++</title><link href="/C++/" rel="alternate" type="text/html" title="C++" /><published>2021-02-09T00:00:00+08:00</published><updated>2021-02-09T00:00:00+08:00</updated><id>/C++</id><content type="html" xml:base="/C++/">&lt;h2 id=&quot;1c语法基础&quot;&gt;1、C++语法基础&lt;/h2&gt;

&lt;h3 id=&quot;指针和引用&quot;&gt;指针和引用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;指针有自己的一块内存空间，引用只是一个别名。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof&lt;/code&gt; 指针大小为4，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof&lt;/code&gt; 引用为被引用对象的大小。&lt;/li&gt;
  &lt;li&gt;引用必须初始化，且是一个已存在对象的引用。指针可以初始化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;可以有const指针，但是没有const引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;程序编译过程&quot;&gt;程序编译过程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。&lt;/li&gt;
  &lt;li&gt;编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。&lt;/li&gt;
  &lt;li&gt;汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。&lt;/li&gt;
  &lt;li&gt;链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;staticconstdefine的用法和区别&quot;&gt;static、const、#define的用法和区别&lt;/h3&gt;
&lt;h4 id=&quot;stacic&quot;&gt;stacic&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;全局静态变量、局部静态变量，位于静态存储区。&lt;/li&gt;
  &lt;li&gt;静态函数，只能在当前.cpp或.c文件访问到&lt;/li&gt;
  &lt;li&gt;类的静态成员：多个对象之间的数据共享，在类的源文件中初始化：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int ClassName::paramName = 0;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;类的静态函数：不能直接引用类中声明的非静态成员，只能引用类中声明的静态成员。可通过如下方式调用：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassName::FuncName();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;const&quot;&gt;const&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;修饰变量，说明变量不可被改变。&lt;/li&gt;
  &lt;li&gt;修饰指针，分为指向常量的指针和指针常量
    &lt;ul&gt;
      &lt;li&gt;指针常量：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int const *p&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 是一个指针，指向常量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const int&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;常量指针：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int* const p&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 是一个常量指针，指向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;形参加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt;，既避免了拷贝，又避免了函数对值的修改。&lt;/li&gt;
  &lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;define和const&quot;&gt;#define和const&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 常量有数据类型，而宏常量没有，编译器可以对const常量进行类型安全检查，而后者只进行字符替换没有安全检查&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 常量存在于程序的数据段，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#define&lt;/code&gt; 常量存在于程序的代码段&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;define&lt;/code&gt; 在预处理阶段进行替换，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 在编译时确定其值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c-和-c-区别&quot;&gt;C 和 C++ 区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;设计思想上：
    &lt;ul&gt;
      &lt;li&gt;C++是面向对象的语言，而C是面向过程的结构化编程语言&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;语法上：
    &lt;ul&gt;
      &lt;li&gt;C++具有封装、继承和多态三种特性&lt;/li&gt;
      &lt;li&gt;C++相比C，增加多许多类型安全的功能，比如强制类型转换、&lt;/li&gt;
      &lt;li&gt;C++支持范式编程，比如模板类、函数模板等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c对象内存模型&quot;&gt;C++对象内存模型&lt;/h3&gt;
&lt;p&gt;虚函数表&lt;/p&gt;

&lt;h3 id=&quot;内存中的栈和堆分配&quot;&gt;内存中的栈和堆分配&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../image/内存结构.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
    &lt;ul&gt;
      &lt;li&gt;代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。&lt;/li&gt;
      &lt;li&gt;数据段：存储程序中已初始化的全局变量和静态变量&lt;/li&gt;
      &lt;li&gt;bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。&lt;/li&gt;
      &lt;li&gt;堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。&lt;/li&gt;
      &lt;li&gt;映射区：存储动态链接库以及调用mmap函数进行的文件映射&lt;/li&gt;
      &lt;li&gt;栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;限制对象堆上或栈上创建&quot;&gt;限制对象堆上或栈上创建&lt;/h3&gt;
&lt;p&gt;1.堆上创建： 析构函数private/protected
2.栈上创建： operator new / operator new [] 私有或protected&lt;/p&gt;

&lt;h2 id=&quot;2面对对象基础&quot;&gt;2、面对对象基础&lt;/h2&gt;

&lt;h3 id=&quot;面向对象理解&quot;&gt;面向对象理解&lt;/h3&gt;

&lt;h3 id=&quot;析构函数构造函数拷贝构造&quot;&gt;析构函数、构造函数、拷贝构造&lt;/h3&gt;

&lt;h3 id=&quot;虚函数多态&quot;&gt;虚函数、多态&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。&lt;/li&gt;
  &lt;li&gt;虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;纯虚函数和虚函数&quot;&gt;纯虚函数和虚函数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41309205&quot;&gt;C++中虚函数、虚继承内存模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;静态多态是通过函数重载实现的；动态多态是通过虚函数实现的&lt;/li&gt;
  &lt;li&gt;构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）&lt;/li&gt;
  &lt;li&gt;纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。&lt;/li&gt;
  &lt;li&gt;虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。&lt;/li&gt;
  &lt;li&gt;带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用&lt;/li&gt;
  &lt;li&gt;将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。&lt;/li&gt;
  &lt;li&gt;C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;虚函数实现机制&quot;&gt;虚函数实现机制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;虚函数表&quot;&gt;虚函数表&lt;/h3&gt;

&lt;h3 id=&quot;访问限定符-publicprivateprotected&quot;&gt;访问限定符 public、private、protected&lt;/h3&gt;

&lt;h3 id=&quot;继承原理虚继承菱形继承&quot;&gt;继承原理、虚继承、菱形继承&lt;/h3&gt;
&lt;p&gt;https://blog.51cto.com/zimomo/1784074&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;菱形继承：D继承B、C，B和C继承A，A有函数Func，D调用Func时调用不明确，&lt;/li&gt;
  &lt;li&gt;一种解决方法是使用域限定：d.A::Func()，d.B::Func().&lt;/li&gt;
  &lt;li&gt;另一种解决方法是虚继承，B和C虚继承A&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;静态绑定和动态绑定&quot;&gt;静态绑定和动态绑定&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;静态绑定：模板函数&lt;/li&gt;
  &lt;li&gt;动态绑定：虚函数、多态&lt;/li&gt;
  &lt;li&gt;静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;newdelete和mallocfree&quot;&gt;new/delete和malloc/free&lt;/h3&gt;
&lt;p&gt;new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数&lt;/p&gt;

&lt;h3 id=&quot;重载重写和隐藏&quot;&gt;重载、重写和隐藏&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中&lt;/li&gt;
  &lt;li&gt;重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写&lt;/li&gt;
  &lt;li&gt;隐藏：不同作用域中，定义的同名函数构成隐藏（不要求函数返回值和函数参数类型相同）。（派生类中与基类同返回值类型、同名和同参数的非虚函数也构成隐藏。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3语法进阶&quot;&gt;3、语法进阶&lt;/h2&gt;

&lt;h3 id=&quot;常用的设计模式&quot;&gt;常用的设计模式&lt;/h3&gt;

&lt;h3 id=&quot;线程安全的单例模式&quot;&gt;线程安全的单例模式&lt;/h3&gt;

&lt;h3 id=&quot;内存溢出和内存泄漏&quot;&gt;内存溢出和内存泄漏&lt;/h3&gt;

&lt;h3 id=&quot;c11新特性汇总&quot;&gt;C++11新特性汇总&lt;/h3&gt;
&lt;p&gt;https://www.lanqiao.cn/courses/605&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于范围的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auto&lt;/code&gt;，需要先初始化&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr&lt;/code&gt; 的类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr_t&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr&lt;/code&gt; 出现的目的是为了替代 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。对于这两个函数来说，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 又被定义为了 0， 那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo(NULL);&lt;/code&gt; 这个语句将会去调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo(int)&lt;/code&gt;，从而导致代码违反直观。
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;lambda 表达式：
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;捕获列表&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;参数列表&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mutable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;可选&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;异常属性&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;返回类型&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 函数体&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;右值引用、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::move&lt;/code&gt; 方法来将左值转换为右值、&lt;a href=&quot;https://juejin.im/post/6861080373913370638&quot;&gt;右值引用，移动语义，完美转发&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move&lt;/code&gt; 实际上并不能移动任何东西，他唯一的功能是将一个左值强制转换为一个右值引用，使我们可以通过右值引用使用该值；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化列表：POD （plain old data，没有构造、析构和虚函数的类或结构体）类型都可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt; 进行初始化&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::function&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::bind&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::placeholder&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unordered_map&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unordered_set&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tuple&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unordered_map&lt;/code&gt; 内部实现了哈希表，因此其查找速度非常的快&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; 内部实现了一个红黑树，有序性，这是map结构最大的优点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/6844904198962675719&quot;&gt;智能指针&lt;/a&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::weak_ptr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt; 是一种智能指针，它能够记录多少个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_ptr&lt;/code&gt; 共同指向一个对象，从而消除显示的调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt;，当引用计数变为零的时候就会将对象自动删除&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::weak_ptr&lt;/code&gt; 是一种弱引用（相比较而言 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt; 就是一种强引用）。弱引用不会引起引用计数增加。为了解决shared_ptr相互引用导致的内存泄漏。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;正则表达式库&lt;/li&gt;
  &lt;li&gt;语言级线程支持，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::thread&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::future&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;静态链接库和动态链接库&quot;&gt;静态链接库和动态链接库&lt;/h3&gt;
&lt;h4 id=&quot;静态链接&quot;&gt;静态链接&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。&lt;/li&gt;
  &lt;li&gt;空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；&lt;/li&gt;
  &lt;li&gt;更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。&lt;/li&gt;
  &lt;li&gt;运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;动态链接&quot;&gt;动态链接&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。&lt;/li&gt;
  &lt;li&gt;共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；&lt;/li&gt;
  &lt;li&gt;更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。&lt;/li&gt;
  &lt;li&gt;性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;强制类型转换&quot;&gt;强制类型转换&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;const_cast：去const，用于将const变量转为非const&lt;/li&gt;
  &lt;li&gt;static_cast：
    &lt;ul&gt;
      &lt;li&gt;用于非多态类型的转换&lt;/li&gt;
      &lt;li&gt;不执行运行时类型检查（转换安全性不如 dynamic_cast）&lt;/li&gt;
      &lt;li&gt;通常用于转换数值数据类型（如 float -&amp;gt; int）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dynamic_cast
    &lt;ul&gt;
      &lt;li&gt;用于多态类型的转换&lt;/li&gt;
      &lt;li&gt;执行运行时类型检查&lt;/li&gt;
      &lt;li&gt;只适用于指针或引用&lt;/li&gt;
      &lt;li&gt;可以在整个类层次结构中移动指针，包括向上转换、向下转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;reinterpret_cast&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;malloc内存分配原理&quot;&gt;malloc内存分配原理&lt;/h3&gt;
&lt;p&gt;https://blog.csdn.net/wz1226864411/article/details/77934941&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;malloc基本的实现原理就是维护一个内存空闲链表，当申请内存空间时，搜索内存空闲链表，找到适配的空闲内存空间，然后将空间分割成两个内存块，一个变成分配块，一个变成新的空闲块。如果没有搜索到，那么就会用sbrk()才推进brk指针来申请内存空间。&lt;/li&gt;
  &lt;li&gt;搜索空闲块最常见的算法有：首次适配，下一次适配，最佳适配。
    &lt;ul&gt;
      &lt;li&gt;首次适配：第一次找到足够大的内存块就分配，这种方法会产生很多的内存碎片。&lt;/li&gt;
      &lt;li&gt;下一次适配：也就是说等第二次找到足够大的内存块就分配，这样会产生比较少的内存碎片。&lt;/li&gt;
      &lt;li&gt;最佳适配：对堆进行彻底的搜索，从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;合并空闲块&quot;&gt;合并空闲块&lt;/h4&gt;
&lt;p&gt;在释放内存块后，如果不进行合并，那么相邻的空闲内存块还是相当于两个内存块，会形成一种假碎片。所以当释放内存后，我们需要将两个相邻的内存块进行合并。&lt;/p&gt;</content><author><name>wangbin</name></author><category term="编程语言" /><category term="C++" /><summary type="html">1、C++语法基础</summary></entry><entry><title type="html">Zookeeper</title><link href="/Zookeeper/" rel="alternate" type="text/html" title="Zookeeper" /><published>2021-02-09T00:00:00+08:00</published><updated>2021-02-09T00:00:00+08:00</updated><id>/Zookeeper</id><content type="html" xml:base="/Zookeeper/">&lt;h2 id=&quot;什么是zookeeper&quot;&gt;什么是Zookeeper&lt;/h2&gt;

&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653193977&amp;amp;idx=1&amp;amp;sn=12319f8cb81f55a40ac461bd0ad9d74e&amp;amp;chksm=8c99f423bbee7d35056ce7ec1b321f33aad15c309de6eba0086cb31a48b975ccb1d695d5a251&amp;amp;scene=21#wechat_redirect&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zookeeper是一个分布式协调服务，可以在分布式系统中共享配置，协调锁资源，提供命名服务。&lt;/li&gt;
  &lt;li&gt;Zookeeper的数据模型很像数据结构当中的树，也很像文件系统的目录。&lt;/li&gt;
  &lt;li&gt;Zookeeper的数据存储基于节点，这种节点叫做Znode。Znode包含了数据、子节点引用、访问权限等等。
    &lt;ul&gt;
      &lt;li&gt;data：Znode存储的数据信息。&lt;/li&gt;
      &lt;li&gt;ACL：记录Znode的访问权限，即哪些人或哪些IP可以访问本节点。&lt;/li&gt;
      &lt;li&gt;stat：包含Znode的各种元数据，比如事务ID、版本号、时间戳、大小等等。&lt;/li&gt;
      &lt;li&gt;child：当前节点的子节点引用，类似于二叉树的左孩子右孩子。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zookeeper是为读多写少的场景所设计。Znode并不是用来存储大规模业务数据，而是用于存储少量的状态和配置信息，每个节点的数据最大不能超过1MB。&lt;/li&gt;
  &lt;li&gt;Zookeeper包含的基本操作：
    &lt;ul&gt;
      &lt;li&gt;create：创建节点&lt;/li&gt;
      &lt;li&gt;delete：删除节点&lt;/li&gt;
      &lt;li&gt;exists：判断节点是否存在&lt;/li&gt;
      &lt;li&gt;getData：获得一个节点的数据&lt;/li&gt;
      &lt;li&gt;setData：设置一个节点的数据&lt;/li&gt;
      &lt;li&gt;getChildren：获取节点下的所有子节点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zookeeper客户端在请求读操作的时候，可以选择是否设置Watch。Watch可以理解成是注册在特定Znode上的触发器。当这个Znode发生改变，也就是调用了create，delete，setData方法的时候，将会触发Znode上注册的对应事件，请求Watch的客户端会接收到异步通知。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;zookeeper的一致性&quot;&gt;Zookeeper的一致性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Zookeeper Service集群是一主多从结构。&lt;/li&gt;
  &lt;li&gt;在更新数据时，首先更新到主节点（这里的节点是指服务器，不是Znode），再同步到从节点。&lt;/li&gt;
  &lt;li&gt;在读取数据时，直接读取任意从节点。&lt;/li&gt;
  &lt;li&gt;为了保证主从节点的数据一致性，Zookeeper采用了ZAB（ZooKeeper Atomic Broadcast）协议，这种协议非常类似于一致性算法Paxos和Raft。&lt;/li&gt;
  &lt;li&gt;ZAB协议所定义的三种节点状态：
    &lt;ul&gt;
      &lt;li&gt;Looking ：选举状态。&lt;/li&gt;
      &lt;li&gt;Following ：Follower节点（从节点）所处的状态。&lt;/li&gt;
      &lt;li&gt;Leading ：Leader节点（主节点）所处状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最大ZXID也就是节点本地的最新事务编号，包含epoch和计数两部分。epoch是纪元的意思，相当于Raft算法选主时候的term。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;zab的崩溃恢复&quot;&gt;ZAB的崩溃恢复&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;假如Zookeeper当前的主节点挂掉了，集群会进行崩溃恢复。ZAB的崩溃恢复分成三个阶段：&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;1leader-election&quot;&gt;1、Leader election&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;选举阶段，此时集群中的节点处于Looking状态。它们会各自向其他节点发起投票，投票当中包含自己的服务器ID和最新事务ID（ZXID）。&lt;/li&gt;
  &lt;li&gt;接下来，节点会用自身的ZXID和从其他节点接收到的ZXID做比较，如果发现别人家的ZXID比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的ZXID所属节点。&lt;/li&gt;
  &lt;li&gt;每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准Leader，状态变为Leading。其他节点的状态变为Following。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2discovery&quot;&gt;2、Discovery&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;发现阶段，用于在从节点中发现最新的ZXID和事务日志。或许有人会问：既然Leader被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？&lt;/li&gt;
  &lt;li&gt;这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个Leader的情况。&lt;/li&gt;
  &lt;li&gt;所以这一阶段，Leader集思广益，接收所有Follower发来各自的最新epoch值。Leader从中选出最大的epoch，基于此值加1，生成新的epoch分发给各个Follower。&lt;/li&gt;
  &lt;li&gt;各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志。Leader选出最大的ZXID，并更新自身历史日志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;3synchronization&quot;&gt;3.Synchronization&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;同步阶段，把Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。&lt;/li&gt;
  &lt;li&gt;自此，故障恢复正式完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;broadcast&quot;&gt;Broadcast&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;什么是Broadcast呢？简单来说，就是Zookeeper常规情况下更新数据的时候，由Leader广播到所有的Follower。其过程如下：&lt;/li&gt;
  &lt;li&gt;1.客户端发出写入数据请求给任意Follower。&lt;/li&gt;
  &lt;li&gt;2.Follower把写入数据请求转发给Leader。&lt;/li&gt;
  &lt;li&gt;3.Leader采用二阶段提交方式，先发送Propose广播给Follower。&lt;/li&gt;
  &lt;li&gt;4.Follower接到Propose消息，写入日志成功后，返回ACK消息给Leader。&lt;/li&gt;
  &lt;li&gt;5.Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Zab协议既不是强一致性，也不是弱一致性，而是处于两者之间的单调一致性。它依靠事务ID和版本号，保证了数据的更新和读取是有序的。&lt;/p&gt;

&lt;h3 id=&quot;zookeeper的应用&quot;&gt;Zookeeper的应用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.分布式锁：这是雅虎研究员设计Zookeeper的初衷。利用Zookeeper的临时顺序节点，可以轻松实现分布式锁。&lt;/li&gt;
  &lt;li&gt;2.服务注册和发现：利用Znode和Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式RPC框架Dubbo。&lt;/li&gt;
  &lt;li&gt;3.共享配置和状态信息：Redis的分布式解决方案Codis，就利用了Zookeeper来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。&lt;/li&gt;
  &lt;li&gt;此外，Kafka、HBase、Hadoop，也都依靠Zookeeper同步节点信息，实现高可用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是分布式锁&quot;&gt;什么是分布式锁&lt;/h2&gt;
&lt;p&gt;http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653194065&amp;amp;idx=1&amp;amp;sn=1baa162e40d48ce9b44ea5c4b2c71ad7&amp;amp;chksm=8c99f58bbbee7c9d5b5725da5ee38fe0f89d7a816f3414806785aea0fe5ae766769600d3e982&amp;amp;scene=21#wechat_redirect&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Redis分布式锁：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set keyname val ex 5 nx&lt;/code&gt;，当keyname不存在时，设置key，过期时间是5秒&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何用zookeeper实现分布式锁&quot;&gt;如何用Zookeeper实现分布式锁&lt;/h2&gt;
&lt;p&gt;http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653194140&amp;amp;idx=1&amp;amp;sn=07b65a50798c26ecdc0fc555128ab937&amp;amp;chksm=8c99f546bbee7c50b1642dc971cb1f5e244dce661546e141734797c8c23c6c3ad779dfb57d3b&amp;amp;scene=21#wechat_redirect&lt;/p&gt;

&lt;h3 id=&quot;znode分为四种类型&quot;&gt;Znode分为四种类型：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.持久节点 （PERSISTENT）：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。&lt;/li&gt;
  &lt;li&gt;2.持久节点顺序节点（PERSISTENT_SEQUENTIAL）：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号&lt;/li&gt;
  &lt;li&gt;3.临时节点（EPHEMERAL）：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。&lt;/li&gt;
  &lt;li&gt;4.临时顺序节点（EPHEMERAL_SEQUENTIAL）：临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;zookeeper分布式锁的原理&quot;&gt;Zookeeper分布式锁的原理&lt;/h3&gt;
&lt;p&gt;Zookeeper分布式锁恰恰应用了临时顺序节点。具体如何实现呢？让我们来看一看详细步骤：&lt;/p&gt;

&lt;h4 id=&quot;获取锁&quot;&gt;获取锁&lt;/h4&gt;
&lt;p&gt;首先，在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点 Lock1。
之后，Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。
这时候，如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。
Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。
于是，Client2向排序仅比它靠前的节点Lock1注册Watcher，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。
这时候，如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。
Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。
于是，Client3向排序仅比它靠前的节点Lock2注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。
这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的AQS（AbstractQueuedSynchronizer）。&lt;/p&gt;

&lt;h4 id=&quot;释放锁&quot;&gt;释放锁&lt;/h4&gt;
&lt;p&gt;释放锁分为两种情况：
1.任务完成，客户端显示释放
当任务完成时，Client1会显示调用删除节点Lock1的指令。
2.任务执行过程中，客户端崩溃
获得锁的Client1在任务执行过程中，如果Duang的一声崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。
由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。
同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。
最终，Client3成功得到了锁。&lt;/p&gt;

&lt;h2 id=&quot;zookeeper如何保证数据一致性&quot;&gt;Zookeeper如何保证数据一致性&lt;/h2&gt;
&lt;p&gt;https://juejin.im/post/6844904163042656263&lt;/p&gt;</content><author><name>wangbin</name></author><category term="系统架构设计" /><summary type="html">什么是Zookeeper</summary></entry><entry><title type="html">Kafka</title><link href="/Kafka/" rel="alternate" type="text/html" title="Kafka" /><published>2021-02-09T00:00:00+08:00</published><updated>2021-02-09T00:00:00+08:00</updated><id>/Kafka</id><content type="html" xml:base="/Kafka/">&lt;h2 id=&quot;kafka&quot;&gt;Kafka&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.jianshu.com/p/5f510cb9d7f1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>wangbin</name></author><category term="系统架构设计" /><summary type="html">Kafka https://www.jianshu.com/p/5f510cb9d7f1</summary></entry><entry><title type="html">计算机网络</title><link href="/ComputerNetwork/" rel="alternate" type="text/html" title="计算机网络" /><published>2021-02-06T00:00:00+08:00</published><updated>2021-02-06T00:00:00+08:00</updated><id>/ComputerNetwork</id><content type="html" xml:base="/ComputerNetwork/">&lt;p&gt;&lt;img src=&quot;../image/tcp报文格式.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;TCP报文格式&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;1osi七层模型tcpip四层&quot;&gt;1、OSI七层模型、TCP/IP四层&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;OSI七层模型&lt;/th&gt;
      &lt;th&gt;TCP/IP模型&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;TCP/IP协议族&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;应用层&lt;/td&gt;
      &lt;td&gt;应用层&lt;/td&gt;
      &lt;td&gt;文件传输，电子邮件，文件服务，虚拟终端&lt;/td&gt;
      &lt;td&gt;TFTP,HTTP:80,SNMP,FTP:21,SMTP:25,DNS:53,Telnet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示层&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;数据格式化，代码转换，数据加密&lt;/td&gt;
      &lt;td&gt;没有协议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;会话层&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;接触或建立别的节点的联系&lt;/td&gt;
      &lt;td&gt;没有协议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;传输层&lt;/td&gt;
      &lt;td&gt;传输层&lt;/td&gt;
      &lt;td&gt;提供端对端的接口&lt;/td&gt;
      &lt;td&gt;TCP,UDP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;网络层&lt;/td&gt;
      &lt;td&gt;网络层&lt;/td&gt;
      &lt;td&gt;为数据选择路由&lt;/td&gt;
      &lt;td&gt;IP,ICMP,RIP,OSPF,BGP,IGMP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据链路层&lt;/td&gt;
      &lt;td&gt;链路层&lt;/td&gt;
      &lt;td&gt;传输有地址的帧以及错误检测功能&lt;/td&gt;
      &lt;td&gt;SLIP,CSLIP,PPP,ARP,RARP,MTU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;物理层&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;以二进制数据形式在物理媒体上传输数据&lt;/td&gt;
      &lt;td&gt;ISO2110,IEEE802,IEEE802.2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;什么是四层模型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等。&lt;/li&gt;
  &lt;li&gt;第二层：传输层，主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。&lt;/li&gt;
  &lt;li&gt;第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）&lt;/li&gt;
  &lt;li&gt;第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2tcp和udp区别&quot;&gt;2、TCP和UDP区别&lt;/h2&gt;
&lt;p&gt;| | UDP | TCP |
|—|—|—|
| 是否连接 | 无连接 | 面向连接 |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信 |
| 传输方式 | 面向报文 | 面向字节流 |
| 首部开销 | 首部开销小，仅8字节 | 首部最小20字节，最大60字节 |
| 适用场景 | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |&lt;/p&gt;

&lt;h2 id=&quot;3tcp协议3次握手4次挥手&quot;&gt;3、TCP协议3次握手、4次挥手&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../image/tcp建立连接3次握手.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;TCP协议3次握手&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;三次握手最主要的目的就是&lt;strong&gt;双方确认自己与对方的发送与接收是正常的&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;31tcp连接建立需要为什么不是两次握手&quot;&gt;3.1、TCP连接建立需要为什么不是两次握手&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;为什么A还要发送一次确认呢？&lt;u&gt;这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误&lt;/u&gt;。&lt;/li&gt;
  &lt;li&gt;所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。&lt;/li&gt;
  &lt;li&gt;现假定出现一种异常情况，即&lt;u&gt;A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B&lt;/u&gt;。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。&lt;/li&gt;
  &lt;li&gt;由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。&lt;/li&gt;
  &lt;li&gt;采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32tcp第三次握手失败会出现什么&quot;&gt;3.2、TCP第三次握手失败会出现什么&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;失败时会超时重传SYN+ACK，重传次数根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc/sys/net/ipv4/tcp_synack_retries&lt;/code&gt; 来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，会给客户端发RST报文，进入CLOSED状态，这个时候客户端应该也会关闭连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33tcp四次挥手&quot;&gt;3.3、TCP四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../image/tcp断开连接4次挥手.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;TCP协议4次挥手&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CLOSE-WAIT 状态问题&lt;/strong&gt;：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN 连接释放报文。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A收到B的FIN报文后，后进入到TIME-WAIT（时间等待）状态&lt;/strong&gt;。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态。时间&lt;u&gt;MSL叫做最长报文段寿&lt;/u&gt;命(Maximum Segment Lifetime)，RFC 793建议设为2分钟。但这完全是从工程上来考虑，对于现在的网络，MSL = 2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。因此，从A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;TIME_WAIT调优
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭
net.ipv4.tcp_syncookies = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1
#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
net.ipv4.tcp_fin_timeout=30

TIME_WAIT：表示主动关闭，通过优化系统内核参数可容易解决。
CLOSE_WAIT：表示被动关闭，需要从程序本身出发。
ESTABLISHED：表示正在通信
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;u&gt;**为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。**&lt;/u&gt;&lt;/li&gt;
  &lt;li&gt;第一，&lt;u&gt;为了保证A发送的最后一个ACK报文段能够到达B&lt;/u&gt;。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN + ACK报文段的确认。B会超时重传这个FIN + ACK报文段，而A就能在2MSL时间内收到这个重传的FIN + ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。&lt;/li&gt;
  &lt;li&gt;第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。&lt;/li&gt;
  &lt;li&gt;B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;342mslmaximum-segment-lifetime意义&quot;&gt;3.4、2MSL(Maximum Segment Lifetime)意义&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、保证最后一次ACK报文能到服务端，能进行超时重传。&lt;/li&gt;
  &lt;li&gt;2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4tcp长连接和短链接及优缺点&quot;&gt;4、TCP长连接和短链接及优缺点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。&lt;/li&gt;
  &lt;li&gt;短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；&lt;/li&gt;
  &lt;li&gt;tcp长连接优缺点：长连接可以省去较多的tcp建立/关闭的操作，减少浪费，节省时间，对于频繁请求资源的客户，较适用于长连接；client和server如果长时间不关闭的话，会存在一个问题，随着客户的越来越多，server早晚会有扛不住的一天，这时需要采取一些策略，如关闭一些长时间不读写操作的连接，这样可以避免一些恶意连接导致server端服务受损，如果条件再允许，就可以以客户端为颗粒度，限制每个客户端的最大连接数&lt;/li&gt;
  &lt;li&gt;tcp短连接优缺点：短连接对于服务器来说较为简单，存在的连接都是有用的连接，不需要额外的控制，但如果客户端连接频繁，会在tcp的建立和关闭上浪费时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5tcp如何保证可靠性&quot;&gt;5、TCP如何保证可靠性&lt;/h2&gt;
&lt;p&gt;https://juejin.im/post/6861491957534261255&lt;/p&gt;

&lt;h3 id=&quot;51差错控制&quot;&gt;5.1、差错控制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;差错控制的方法有：&lt;strong&gt;校验和、确认应答、重传&lt;/strong&gt; 三种&lt;/li&gt;
  &lt;li&gt;TCP 通过首部中的校验和字段，判断数据是否损坏，如果损坏，则直接丢弃。&lt;/li&gt;
  &lt;li&gt;在 TCP 中，发送端的数据到达接收端时，接收端会返回一个“我收到消息了”的通知，这个通知就是确认应答（ACK, Acknowledge character）。&lt;/li&gt;
  &lt;li&gt;TCP共实现了两种重传机制：超时重传和快重传&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;511超时重传&quot;&gt;5.1.1、超时重传&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当发送端发送数据后，如果在特定时间间隔内还没有收到 ACK，就会进行超时重传。特定时间：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTT&lt;/code&gt; + 偏差值，Round Trip Time 报文段的往返时间，如果网络稳定性较差，那么相应的偏差值也会较大，相反的，若网络比较稳定，则偏差值也会较小。&lt;/li&gt;
  &lt;li&gt;由于最初的数据包还不知道其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTT&lt;/code&gt;，所以其超时重传时间一般设置为 6秒。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;512快重传&quot;&gt;5.1.2、快重传&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;快重传基于窗口控制（后面会讲到），是指发送端在连续三次收到同一个确认应答后，就会将其对应的数据进行重发，这种机制比超时重传更加高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;52流量控制&quot;&gt;5.2、流量控制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。&lt;/li&gt;
  &lt;li&gt;TCP 以一个段为单位，每发送一个段就要进行一次确认应答（ACK）处理，这样传输的方式有一个缺点，就是包的往返时间越长，效率就越低。&lt;/li&gt;
  &lt;li&gt;所以 TCP 引入了 窗口 这个概念，在窗口范围内，即使没有收到 ACK，也可以继续发送数据，无需一直等待 ACK，这个机制的实现使用了大量的缓冲区。&lt;/li&gt;
  &lt;li&gt;通过流量控制，发送端需要根据接收端的实际接收能力控制发送的数据量。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;利用滑动窗口实现流量控制&lt;/strong&gt;，滑动窗口以字节为单位。&lt;/li&gt;
  &lt;li&gt;TCP 首部中带有窗口大小字段，在返回 ACK 时，就会带上这个字段，接收端接收到了这个字段后，就对会自己的窗口大小进行更新（滑动）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../image/滑动窗口.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;滑动窗口&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../image/滑动窗口发送.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;滑动窗口发送&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;53拥塞控制&quot;&gt;5.3、拥塞控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../image/慢开始和拥塞避免算法.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;慢开始与拥塞避免算法&lt;/center&gt;&lt;/strong&gt;
&lt;img src=&quot;../image/拥塞窗口大小.jpg&quot; alt=&quot;image&quot; /&gt;
&lt;strong&gt;&lt;center&gt;拥塞窗口大小&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;拥塞&lt;/strong&gt;是由于网络中的路由器由于超载而引起的严重延迟现象，拥塞的发生会造成数据丢失，进而引发超时重传，而超时重传又会进一步加剧拥塞，如果不进行控制，最终会导致整个网络的瘫痪。&lt;/li&gt;
  &lt;li&gt;拥塞控制主要通过利用发送窗口限制数据流的速度，减缓注入网络的数据流量后，拥塞自然就会解除。&lt;/li&gt;
  &lt;li&gt;而起关键作用的发送窗口的大小，取决于两个因素，一个是接收窗口的大小，另一个就是拥塞窗口。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;慢启动&lt;/strong&gt;：定义拥塞窗口，一开始将该窗口大小设为1MSS（1460字节），之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拥塞避免&lt;/strong&gt;：设置慢启动阈值（ssthresh），一般开始都设为65535字节。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1MSS），以此来避免拥塞。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拥塞检测&lt;/strong&gt;：超时重传或连续收到三个相同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;，则认为发生拥塞。
    &lt;ul&gt;
      &lt;li&gt;一旦发生超时重传，我们需要先将&lt;strong&gt;慢启动阈值&lt;/strong&gt;设为当前窗口大小的一半，并且将拥塞窗口大小设置为1MSS，然后重新进入慢启动阶段。&lt;/li&gt;
      &lt;li&gt;如果连续收到了三个相同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;，将慢启动阀值设为当前窗口的一半，拥塞窗口设置为慢启动阀值+3。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6tcp如何解决粘包拆包问题&quot;&gt;6、TCP如何解决粘包、拆包问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;消息数据定长，比如定长100字节&lt;/li&gt;
  &lt;li&gt;消息数据使用特定分割符区分界限，比如使用换号符号做分割&lt;/li&gt;
  &lt;li&gt;把消息数据分成消息头和消息体，消息头带消息的长度，接收方收到后根据消息头中的长度解析数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7udp如何实现tcp可靠传输&quot;&gt;7、UDP如何实现TCP可靠传输&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1、添加seq/ack机制，确保数据发送到对端&lt;/li&gt;
  &lt;li&gt;2、添加发送和接收缓冲区，主要是用户超时重传。&lt;/li&gt;
  &lt;li&gt;3、添加超时重传机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8arp&quot;&gt;8、ARP&lt;/h2&gt;
&lt;h3 id=&quot;arp解析过程&quot;&gt;ARP解析过程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ARP地址解析协议，将IP地址解析为MAC地址。&lt;/li&gt;
  &lt;li&gt;主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。&lt;/li&gt;
  &lt;li&gt;为了确定目标的MAC地址，首先查找ARP缓存表。如果要查找的MAC地址不在表中，ARP会发送一个广播，从而发现目的地的MAC地址，并记录到ARP缓存表中以便下次查找。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;将ip地址解析到mac地址。&lt;/li&gt;
  &lt;li&gt;目标IP与自己在同一网段：
    &lt;ul&gt;
      &lt;li&gt;arp高速缓存有目标IP的MAC地址：直接发送到该物理地址&lt;/li&gt;
      &lt;li&gt;arp高速缓存没有目标IP的MAC地址：发送ARP广播请求目标IP的MAC地址，缓存该MAC地址，然后发数据报到该MAC地址。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;目标IP与自己不在同一个网段：这种情况需要将包发给默认网关，所以主要获取网关的MAC地址
    &lt;ul&gt;
      &lt;li&gt;arp高速缓存有默认网关的MAC地址：直接发送IP数据报道默认网关，再由网关转发到外网。&lt;/li&gt;
      &lt;li&gt;arp高速缓存没有默认网关的MAC地址 ：还是发送ARP广播请求默认网关的MAC地址，缓存该地址，并且发送数据报到网关。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9dns原理&quot;&gt;9、DNS原理&lt;/h2&gt;

&lt;h3 id=&quot;91dns解析过程&quot;&gt;9.1、DNS解析过程&lt;/h3&gt;
&lt;p&gt;(https://www.jianshu.com/p/189311c71b0e)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器缓存：查看浏览器缓存的域名与IP的映射关系，如果有则解析成功。&lt;/li&gt;
  &lt;li&gt;主机缓存：浏览器缓存没命中，查询主机DNS缓存。&lt;/li&gt;
  &lt;li&gt;LDNS（本地域名服务器）：本机缓存没命中，则查找本地域名服务器。&lt;/li&gt;
  &lt;li&gt;Root Server：LDNS没有查到，就会发送请求到Root Server。Root Server不直接解析域名，它会返回所查询域的gTLD地址。&lt;/li&gt;
  &lt;li&gt;gTLD服务器：gTLD为国际顶级域名服务器，如 .com，.cn，.org都由它管理。LDNS发送请求到gTLD，gTLD返回对应域名的Name Server服务器地址。&lt;/li&gt;
  &lt;li&gt;Name Server（域名服务器）：Name Server为域名提供商的域名解析服务器。域名最终在这里解析，上述步骤要么是缓存，要么是提供域名解析服务器地址。想想也挺合理，在哪买的域名就在哪绑定IP。&lt;/li&gt;
  &lt;li&gt;DNS劫持：在DNS服务器中，将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.xxx.com&lt;/code&gt; 的域名对应的IP地址进行了变化。你解析出来的 域名对应的IP，在劫持前后不一样。&lt;/li&gt;
  &lt;li&gt;DNS劫持：域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;92dns使用tcp还是udp&quot;&gt;9.2、DNS使用TCP还是UDP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DNS在区域传输的时候使用TCP协议,其他时候使用UDP协议。&lt;/li&gt;
  &lt;li&gt;DNS同时占用TCP和UDP的53号端口。&lt;/li&gt;
  &lt;li&gt;因为查询很频繁，使用UDP报文给服务器带来的负担小，所以查询的时候使用的是UDP报文。&lt;/li&gt;
  &lt;li&gt;主副DNS进行区域传送的时候，用TCP，因为要保证数据的准确性。&lt;/li&gt;
  &lt;li&gt;DNS区域传输的时候使用TCP协议：
    &lt;ul&gt;
      &lt;li&gt;1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。&lt;/li&gt;
      &lt;li&gt;2.TCP是一种可靠连接，保证了数据的准确性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;域名解析时使用UDP协议：
    &lt;ul&gt;
      &lt;li&gt;客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;10http常见问题&quot;&gt;10、HTTP常见问题&lt;/h2&gt;
&lt;p&gt;(https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 是超文本传输协议，也就是HyperText Transfer Protocol&lt;/li&gt;
  &lt;li&gt;HTTP 常见的状态码，有哪些？
    &lt;ul&gt;
      &lt;li&gt;1xx 类状态码属于提示信息&lt;/li&gt;
      &lt;li&gt;2xx 类状态码表示服务器成功处理了客户端的请求。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;200 OK&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;301 Moved Permanently&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;4xx 类状态码表示客户端发送的报文有误。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400 Bad Request、403 Forbidden、404 Not Found&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;500 Internal Server Error、501 Not Implemented、502 Bad Gateway、503 Service Unavailable&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 常见字段有：Host、Content-Length、Connection、Content-Type、Content-Encoding、&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GET 和 POST 的区别？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。&lt;/li&gt;
      &lt;li&gt;POST 向 URI 指定的资源提交数据，数据就放在报文的 body 里。&lt;/li&gt;
      &lt;li&gt;GET 方法就是安全且幂等，POST是不安全的，不是幂等的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」，缺点是无状态、明文传输、不安全（通信使用明文（不加密），内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改）。&lt;/li&gt;
  &lt;li&gt;HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致&lt;/li&gt;
  &lt;li&gt;HTTP/1.1 提出了长连接的通信方式，减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。&lt;/li&gt;
  &lt;li&gt;HTTP/1.1 相比 HTTP/1.0 性能上的改进：
    &lt;ul&gt;
      &lt;li&gt;使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。&lt;/li&gt;
      &lt;li&gt;支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../image/http请求报文.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;POST /index.html HTTP/1.1
HOST: www.XXX.com
User-Agent: Mozilla/5.0(Windows NT 6.1;rv:15.0) Firefox/15.0

Username=admin&amp;amp;password=admin
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../image/http响应报文.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;this is http response&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP有两种报文：请求报文和响应报文。
    &lt;ul&gt;
      &lt;li&gt;HTTP请求报文主要包括请求行、请求头部以及请求的数据（实体）三部分
        &lt;ul&gt;
          &lt;li&gt;请求行（HTTP请求报文的第一行）：请求行由方法字段、URL字段和HTTP协议版本字段。其中，方法字段严格区分大小写，当前HTTP协议中的方法都是大写，方法字段如下介绍如下：&lt;/li&gt;
          &lt;li&gt;请求头部：位于请求行的下面, 是一个个的key-value值&lt;/li&gt;
          &lt;li&gt;空行(CR+LF)：请求报文用空行表示header和请求数据的分隔&lt;/li&gt;
          &lt;li&gt;请求数据：GET方法没有携带数据， POST方法会携带一个body&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HTTP的响应报文包括：状态行，响应头部，相应的数据(响应体)
        &lt;ul&gt;
          &lt;li&gt;状态行包括：HTTP版本号，状态码和状态值组成。&lt;/li&gt;
          &lt;li&gt;响应头类似请求头，是一系列key-value值&lt;/li&gt;
          &lt;li&gt;空白行：同上，响应报文也用空白行来分隔header和数据&lt;/li&gt;
          &lt;li&gt;响应体：响应的数据&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11什么是-https-协议&quot;&gt;11、什么是 HTTPS 协议&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://segmentfault.com/a/1190000012196642&lt;/li&gt;
  &lt;li&gt;http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653197101&amp;amp;idx=1&amp;amp;sn=d1fe482561d3d079363032ec182c5b3b&amp;amp;chksm=8c99e1f7bbee68e10f8470453637a7d434751a9414ceeffbbb9601f5ae2ba64e26fa6a88a99b&amp;amp;scene=21#wechat_redirect&lt;/li&gt;
  &lt;li&gt;SSL（Secure Socket Layer，安全套接字层）&lt;/li&gt;
  &lt;li&gt;TLS（Transport Layer Security，传输层安全）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对称加密算法和非对称加密算法&quot;&gt;对称加密算法和非对称加密算法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTPS在加密过程中使用了非对称加密技术和对称加密技术。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对称加密算法&lt;/strong&gt;：又称共享密钥加密算法，指加密和解密使用相同密钥的加密算法。对称加密算法用来对敏感数据等信息进行加密，常用的算法包括DES、3DES、AES、DESX、Blowfish、RC4、RC5、RC6。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非对称加密算法&lt;/strong&gt;：指加密和解密使用不同密钥的加密算法，也称为公私钥加密/公开密钥加密算法。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。常见的非对称加密算法：RSA、DSA（数字签名用）、ECC（移动设备用）、Diffie-Hellman、El Gamal。
    &lt;ul&gt;
      &lt;li&gt;当客户端第一次发请求和服务器协商的时候，服务器就生成了一对公钥和私钥。&lt;/li&gt;
      &lt;li&gt;紧接着，服务器把公钥发给客户端（明文，不需要做任何加密），客户端接收后，随机生成一个密钥，使用服务器发过来的公钥进行加密。&lt;/li&gt;
      &lt;li&gt;再接着，客户端把使用公钥加密的密钥发给服务器，服务器接收到了以后，用配对的私钥进行解密，就得到了客户端随机生成的那个密钥。&lt;/li&gt;
      &lt;li&gt;这个时候，客户端和服务端所持的密钥都是相同的。此时，交换密钥环节就完成了。&lt;/li&gt;
      &lt;li&gt;于是通信开始时就可进行共享密钥加密方式来进行加密。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如何保证服务器传过来的公开密钥的正确性&lt;/strong&gt;。换句话说，就是保证它不被拦截篡改。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;使用证书保证公钥的正确性&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;首先，服务器的运营人员向数字证书机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。&lt;/li&gt;
      &lt;li&gt;接下来，服务器会把这份由数字证书认证机构颁发的公钥证书发给客户端。这个时候，客户端可以使用数字证书机构的公开密钥对其进行验证。一旦验证成功，客户端便能够确定这个公开密钥是可信的。&lt;/li&gt;
      &lt;li&gt;CA除了给申请者发布证书，它自己本身也有自己的证书。CA自身的数字证书（一般由它自己生成）在我们操作系统刚安装好的时候，这些CA自身的数字证书就已经被微软（或者其它操作系统的开发机构）安装在操作系统中了。而CA的公钥就包含在其中。这样，CA就可以通过自身的私钥对发布的数字证书进行签名，而在客户端就能够用对应的公钥来对其进行解密。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12http和https区别&quot;&gt;12、HTTP和HTTPS区别&lt;/h2&gt;
&lt;h3 id=&quot;121http和https区别&quot;&gt;12.1、HTTP和HTTPS区别：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1）HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。&lt;/li&gt;
  &lt;li&gt;2）HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。&lt;/li&gt;
  &lt;li&gt;3）HTTP 的端口号是 80，HTTPS 的端口号是 443。&lt;/li&gt;
  &lt;li&gt;4）HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;122https优点&quot;&gt;12.2、HTTPS优点：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTPS传输数据过程中使用密钥进行加密，所以安全性更高。（HTTPS 采用的加密方式: HTTPS 采用混合的加密机制。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。）&lt;/li&gt;
  &lt;li&gt;HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;123https缺点&quot;&gt;12.3、HTTPS缺点：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加&lt;/li&gt;
  &lt;li&gt;HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;13http10http11http20区别&quot;&gt;13、HTTP1.0、HTTP1.1、HTTP2.0区别&lt;/h2&gt;

&lt;h3 id=&quot;131http10-和-http11-的区别&quot;&gt;13.1、HTTP1.0 和 HTTP1.1 的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;长连接&lt;/strong&gt;(Persistent Connection)：HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节约带宽&lt;/strong&gt;：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HOST域&lt;/strong&gt;：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓存处理&lt;/strong&gt;：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;错误通知的管理&lt;/strong&gt;：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;132http11和http20的区别&quot;&gt;13.2、HTTP1.1和HTTP2.0的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;头部数据压缩&lt;/strong&gt;：在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;14浏览器输入网址&quot;&gt;14、浏览器输入网址&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1、浏览器查找域名的IP地址 （DNS：获取域名对应的IP）
2、浏览器向web服务器发送HTTP请求（cookies会随着请求发送给服务器）
3、服务器处理请求 （请求 处理请求 参数、cookies、生成一个HTML响应）
4、服务器返回HTTP报文，发回一个HTML响应。
5、浏览器解析渲染页面，浏览器开始显示HTML。
6、连接结束 - 浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 - 得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。 其中：
- 1、DNS协议，http协议，https协议属于应用层：应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。
- 2、TCP/UDP属于传输层：传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。
- 3、IP协议，ARP协议属于网络层：网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。
- 4、数据链路层：当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。
- 5、物理层：物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15广播风暴&quot;&gt;15、广播风暴&lt;/h2&gt;
&lt;p&gt;广播风暴也叫网络广播风暴，广播风暴(broadcast storm)故障，即一个数据包或帧被传送到本地网段(由广播域定义)上的每个节点就是广播；网络上的广播帧由于被转发，数量急剧增加而出现正常网络通信的反常现象。广播风暴会占用相当可观的网络带宽，导致正常数据包无法正常运行。当广播数据充斥网络无法处理并占用大量网络带宽，导致正常业务不能运行，这就发生了广播风暴，造成局域网局部或整个网络瘫痪。&lt;/p&gt;</content><author><name>wangbin</name></author><category term="计算机基础知识" /><summary type="html">TCP报文格式</summary></entry><entry><title type="html">算法与数据结构</title><link href="/DataStructure/" rel="alternate" type="text/html" title="算法与数据结构" /><published>2021-02-05T00:00:00+08:00</published><updated>2021-02-05T00:00:00+08:00</updated><id>/DataStructure</id><content type="html" xml:base="/DataStructure/">&lt;h2 id=&quot;常见算法类型&quot;&gt;常见算法类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;排序算法（冒泡、插入、选择、快排、希尔、堆排、归并、桶排、基数、计数）、字符串操作、数组操作、递归、回溯、分治、动态规划等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何准备算法可见历史文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTcxNjg5OA==&amp;amp;mid=2247483913&amp;amp;idx=1&amp;amp;sn=7038fe493411992bef3241336cc4fa82&amp;amp;chksm=ea576cc4dd20e5d2a40f846264a80669328160dbce734186b3c6e037f2c9d7871670d8d25b8f&amp;amp;scene=21#wechat_redirect&quot;&gt;进入BAT和字节跳动最难的一关，手撕代码！&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;排序算法&quot;&gt;排序算法&lt;/h4&gt;
&lt;p&gt;https://www.cnblogs.com/onepixel/articles/7674659.html&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB0546b15f74e6207df236ff5f025af575?method=download&amp;amp;shareKey=55a68a29e72221cec8c3aa37ded4b4b7&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653194666&amp;amp;idx=1&amp;amp;sn=69ce32870c0b981c40b1e124fbb6bba8&amp;amp;chksm=8c99fb70bbee72668cad223892ad362525d215e7f936458f99dd289eb82981099359310e9e54&amp;amp;scene=21#wechat_redirect&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653195042&amp;amp;idx=1&amp;amp;sn=2b0915cd2298be9f2163cc90a3d464da&amp;amp;chksm=8c99f9f8bbee70eef627d0f5e5b80a604221abb3a1b5617b397fa178582dcb063c9fb6f904b3&amp;amp;scene=21#wechat_redirect&quot;&gt;快速排序&lt;/a&gt;
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  		&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  		&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;QSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;QSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653195208&amp;amp;idx=1&amp;amp;sn=e3d6559402148458f0a4993b47d8bc6f&amp;amp;chksm=8c99f912bbee7004625a0b204acc8484acbdf4f1b18953e7ff5acbea958ec002d8c8ea072792&amp;amp;scene=21#wechat_redirect&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;二叉堆本质上是一种完全二叉树，分为最大堆和最小堆。
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;大顶堆：priority_queue&amp;lt;int&amp;gt;，即 priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt;&amp;gt; q;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;小顶堆：priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;二叉树前序、中序、后序递归遍历及非递归遍历。
    &lt;ul&gt;
      &lt;li&gt;前序遍历：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&lt;/li&gt;
      &lt;li&gt;中序遍历：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/&lt;/li&gt;
      &lt;li&gt;后序遍历：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 前序，根左右&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 中序，左根右&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inorderTraversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 后续，根右左的逆序&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postorderTraversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;常用数据结构&quot;&gt;常用数据结构&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;务必熟悉底层原理和实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;链表、栈、队列、树(二叉树、平衡二叉树、红黑树、B树、B+树、哈夫曼树、字典树)、跳表、图&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;avl树红黑树&quot;&gt;AVL树、红黑树&lt;/h4&gt;
&lt;p&gt;红黑树：https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653204996&amp;amp;idx=2&amp;amp;sn=ecf932d2db8cb6e4fcb841a2b6a5bfba&amp;amp;chksm=8c99c0debbee49c86dc8e82a2d195389a93e81d8e5ca8af7d4dd2eec5c7fe209038c91444964&amp;amp;scene=21#wechat_redirect
B-树：https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653190965&amp;amp;idx=1&amp;amp;sn=53f78fa037386f85531832cd5322d2a0&amp;amp;chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&amp;amp;scene=21#wechat_redirect
B+树：https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653191027&amp;amp;idx=1&amp;amp;sn=4ba22e3ec8bd149f69fc0aba72e4347e&amp;amp;chksm=8c9909a9bbee80bfa1d8497ff0525df130414c1731b5aa5287bf16ea1cf86c8d8e6f20782184&amp;amp;scene=21#wechat_redirect&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AVL树（平衡二叉树）（AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis）本质上还是一棵二叉搜索树，它的特点是：
    &lt;ul&gt;
      &lt;li&gt;1.本身首先是一棵二叉搜索树。&lt;/li&gt;
      &lt;li&gt;2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;红黑树是一颗AVL树，同时满足下面的特性：
    &lt;ul&gt;
      &lt;li&gt;1.结点是红色或黑色。&lt;/li&gt;
      &lt;li&gt;2.根结点是黑色。&lt;/li&gt;
      &lt;li&gt;3.每个叶子结点都是黑色的空结点（NIL结点）。&lt;/li&gt;
      &lt;li&gt;4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)&lt;/li&gt;
      &lt;li&gt;5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在需要频繁查找时，选用AVL树更合适，在需要频繁插入删除时，选用红黑树更合适。&lt;/li&gt;
  &lt;li&gt;一个m阶的B-树具有如下几个特征：
    &lt;ul&gt;
      &lt;li&gt;1.根结点至少有两个子女。&lt;/li&gt;
      &lt;li&gt;2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &amp;lt;= k &amp;lt;= m&lt;/li&gt;
      &lt;li&gt;3.每一个叶子节点都包含k-1个元素，其中 m/2 &amp;lt;= k &amp;lt;= m&lt;/li&gt;
      &lt;li&gt;4.所有的叶子结点都位于同一层。&lt;/li&gt;
      &lt;li&gt;5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;B-树主要用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。大部分关系型数据库比如MySql则使用B+树作为索引。
&lt;img src=&quot;../image/B树.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;一个m阶的B+树具有如下几个特征：
    &lt;ul&gt;
      &lt;li&gt;1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。&lt;/li&gt;
      &lt;li&gt;2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/li&gt;
      &lt;li&gt;3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
&lt;img src=&quot;../image/B+树.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;B+树的优势：
    &lt;ul&gt;
      &lt;li&gt;1.单一节点存储更多的元素，使得查询的IO次数更少。&lt;/li&gt;
      &lt;li&gt;2.所有查询都要查找到叶子节点，查询性能稳定。&lt;/li&gt;
      &lt;li&gt;3.所有叶子节点形成有序链表，便于范围查询。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hash表设计一致性hash&quot;&gt;Hash表设计、一致性Hash&lt;/h4&gt;
&lt;p&gt;一致性Hash：https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653191083&amp;amp;idx=1&amp;amp;sn=c68c8bb7e18c4d46b85666be10e9ef50&amp;amp;chksm=8c990971bbee80675b6cd0ac3c2c17546cd434c3636616e559ca5cf10d1815c3aed24bfd3c83&amp;amp;scene=21#wechat_redirect&lt;/p&gt;
&lt;h6 id=&quot;hash表设计&quot;&gt;Hash表设计：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;哈希函数的设计：对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等&lt;/li&gt;
  &lt;li&gt;解决哈希冲突
    &lt;ul&gt;
      &lt;li&gt;开放定址法: 开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。&lt;/li&gt;
      &lt;li&gt;再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。&lt;/li&gt;
      &lt;li&gt;链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中&lt;/li&gt;
      &lt;li&gt;建立公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;推荐书籍&quot;&gt;推荐书籍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;《大话数据结构》适合入门学习&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;《剑指offer》必刷66题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;《算法导论》尽量看，能啃完就是大神&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>wangbin</name></author><category term="数据结构和算法" /><summary type="html">常见算法类型</summary></entry><entry><title type="html">数据库</title><link href="/Database/" rel="alternate" type="text/html" title="数据库" /><published>2021-02-05T00:00:00+08:00</published><updated>2021-02-05T00:00:00+08:00</updated><id>/Database</id><content type="html" xml:base="/Database/">&lt;h2 id=&quot;事务的acid特性&quot;&gt;事务的ACID特性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。&lt;/li&gt;
  &lt;li&gt;事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。&lt;/li&gt;
  &lt;li&gt;原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。（原子性实现原理 - Undo Log）&lt;/li&gt;
  &lt;li&gt;一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。&lt;/li&gt;
  &lt;li&gt;隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。（隔离性实现原理 - 锁）&lt;/li&gt;
  &lt;li&gt;持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。（持久性实现原理 - Redo Log）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;隔离级别&quot;&gt;隔离级别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Read Uncommitted（读取未提交）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。&lt;/li&gt;
  &lt;li&gt;Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。&lt;/li&gt;
  &lt;li&gt;Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。&lt;/li&gt;
  &lt;li&gt;Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;脏读：一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。
不可重复读：一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。
幻读：一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不同事务隔离级别有不同的效果：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;隔离级别&lt;/th&gt;
      &lt;th&gt;脏读&lt;/th&gt;
      &lt;th&gt;不可重复读&lt;/th&gt;
      &lt;th&gt;幻读&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;读未提交&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;读已提交&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可重复读&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可串行化&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;数据库引擎innodbmyisam&quot;&gt;数据库引擎InnoDB、MyISAM&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。&lt;/li&gt;
  &lt;li&gt;MyISAM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyISAM中存储了表的行数。&lt;/li&gt;
  &lt;li&gt;https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL?id=myisam%e5%92%8cinnodb%e5%8c%ba%e5%88%ab&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mvcc实现原理&quot;&gt;MVCC实现原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Multi-Version Concurrency Control，即多版本并发控制。&lt;/li&gt;
  &lt;li&gt;InnoDB 的 MVCC, 是通过在每行记录后面保存两个隐藏的列来实现的, 这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值, 而是系统版本号 (可以理解为事务的 ID)，每次开始一个新的事务，系统版本号就会自动递增；当删除一条数据的时候，该数据的删除时间列就会存上当前事务的版本号 ；事务开始时刻的系统版本号会作为事务的 ID；&lt;/li&gt;
  &lt;li&gt;https://juejin.cn/post/6844903986143690765&lt;/li&gt;
  &lt;li&gt;https://segmentfault.com/a/1190000012650596&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;innodb存储引擎在数据库每行数据的后面添加了三个字段&quot;&gt;InnoDB存储引擎在数据库每行数据的后面添加了三个字段&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert&lt;/td&gt;
          &lt;td&gt;update)的事务的标识符, 即最后一次修改(insert&lt;/td&gt;
          &lt;td&gt;update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。&lt;/li&gt;
  &lt;li&gt;6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例分析&quot;&gt;案例分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../image/mvcc.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般我们认为MVCC有下面几个特点：
    &lt;ul&gt;
      &lt;li&gt;每行数据都存在一个版本，每次数据更新时都更新该版本&lt;/li&gt;
      &lt;li&gt;修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰&lt;/li&gt;
      &lt;li&gt;保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)&lt;/li&gt;
      &lt;li&gt;就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而InnoDB实现MVCC的方式是:
    &lt;ul&gt;
      &lt;li&gt;事务以排他锁的形式修改原始数据&lt;/li&gt;
      &lt;li&gt;把修改前的数据存放于undo log，通过回滚指针与主数据关联&lt;/li&gt;
      &lt;li&gt;修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）&lt;/li&gt;
      &lt;li&gt;二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？&lt;/li&gt;
      &lt;li&gt;Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。&lt;/li&gt;
      &lt;li&gt;比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。&lt;/li&gt;
      &lt;li&gt;也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库索引及底层实现&quot;&gt;数据库索引及底层实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;唯一索引：唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中不可以重复&lt;/li&gt;
  &lt;li&gt;非唯一索引：非唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中可以重复，不要求唯一。&lt;/li&gt;
  &lt;li&gt;主键索引（主索引）：主键索引（主索引）是唯一索引的特定类型。表中创建主键时自动创建的索引 。一个表只能建立一个主索引。&lt;/li&gt;
  &lt;li&gt;聚集索引/非聚集索引：聚集索引（聚簇索引），表中记录的物理顺序与键值的索引顺序相同。一个表只能有一个聚集索引。InnoDB 使用 B+ 树，既可以保存实际数据，也可以加速数据搜索，这就是聚簇索引&lt;/li&gt;
  &lt;li&gt;聚集索引：https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97?id=_6-%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%8e%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分布式事务&quot;&gt;分布式事务&lt;/h2&gt;
&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653193461&amp;amp;idx=1&amp;amp;sn=d69ccec780ae6d3b0c722cf09fa154d1&amp;amp;chksm=8c99f62fbbee7f39cd221bd0ecc9105a5c16e353d82d2407e7f295da9f9172cfd4889d3f12c8&amp;amp;scene=21#wechat_redirect)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分布式事务用于在分布式系统中保证不同节点之间的数据一致性。&lt;/li&gt;
  &lt;li&gt;分布式事务的实现有很多种，最具有代表性的是由Oracle Tuxedo系统提出的XA分布式事务协议。&lt;/li&gt;
  &lt;li&gt;XA协议包含两阶段提交（2PC）和三阶段提交（3PC）两种实现，这里我们重点介绍两阶段提交的具体过程。&lt;/li&gt;
  &lt;li&gt;事务的发起者称协调者，事务的执行者称参与者。
&lt;img src=&quot;../image/2PC第一阶段.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;第一阶段：
    &lt;ul&gt;
      &lt;li&gt;在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。&lt;/li&gt;
      &lt;li&gt;在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。&lt;/li&gt;
      &lt;li&gt;当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。
&lt;img src=&quot;../image/2PC第二阶段.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二阶段：
    &lt;ul&gt;
      &lt;li&gt;在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。&lt;/li&gt;
      &lt;li&gt;接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。&lt;/li&gt;
      &lt;li&gt;当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XA两阶段提交的不足：
    &lt;ul&gt;
      &lt;li&gt;1.性能问题：XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。&lt;/li&gt;
      &lt;li&gt;2.协调者单点故障问题：事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。&lt;/li&gt;
      &lt;li&gt;3.丢失消息导致的不一致问题：在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何避免XA两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：
    &lt;ul&gt;
      &lt;li&gt;1.XA三阶段提交：XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。CanCommit、PreCommit、DoCommit&lt;/li&gt;
      &lt;li&gt;2.MQ事务：利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。&lt;/li&gt;
      &lt;li&gt;3.TCC事务：TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;缓存穿透击穿雪崩&quot;&gt;缓存穿透、击穿、雪崩&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求&lt;/li&gt;
  &lt;li&gt;缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。&lt;/li&gt;
  &lt;li&gt;缓存雪崩是因为大面积的缓存失效，打崩了DB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql主从复制&quot;&gt;mysql主从复制&lt;/h2&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/342666786
&lt;img src=&quot;../image/mysql主从复制.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;主从复制原理：主从复制中有两个很重要的日志文件，binlog和relay log，分别位于主库与从库中。其中 binlog 是主从复制的基础，通过将操作事件写入 binlog 通过 I/O 线程传送至从库进行同步。&lt;/li&gt;
  &lt;li&gt;主从延迟原因：
    &lt;ul&gt;
      &lt;li&gt;从库中 SQL 线程重放的过程是随机写盘的，并且 SQL 线程是单线程的，因此数据来不及重放的话就会导致主从延迟。&lt;/li&gt;
      &lt;li&gt;主库并发高会导致写操作不断写入 binlog，对于 SQL 线程说可能会应接不暇，也会产生主从延迟。&lt;/li&gt;
      &lt;li&gt;重放过程中如果遇到锁等待也是产生延迟的原因之一。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主从延迟处理：MySQL 5.6版本以后通过并行复制的方式来解决 SQL 单线程产生的主从延迟问题。对于低版本来说，可以通过降低主库的并发来解决。如果对数据实时性要求比较严格的话，可以通过读主库来达到目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql日记系统redo-logbinlogundo-log&quot;&gt;MySQL日记系统redo log、binlog、undo log&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;物理日志redo log和逻辑日志binlog&lt;/li&gt;
  &lt;li&gt;redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。&lt;/li&gt;
  &lt;li&gt;redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。&lt;/li&gt;
  &lt;li&gt;redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库高并发解决方法&quot;&gt;数据库高并发解决方法&lt;/h2&gt;
&lt;p&gt;1、查询优化
    - 尽量减少对数据库的访问次数
    - 尽量减少对表的访问行数,最小化结果集
    - 能够分开的操作尽量分开处理，提高每次的响应速度
    - 在数据窗口使用SQL时，尽量把使用的索引放在选择的首列
    - 在查询时，不要过多地使用通配符如SELECT * FROM T1语句，要用到几列就选择几列
    - 在可能的情况下尽量限制尽量结果集行数
2、部署优化：分库分表&lt;/p&gt;

&lt;h2 id=&quot;慢查询日志&quot;&gt;慢查询日志&lt;/h2&gt;
&lt;p&gt;慢查询日志是将mysql服务器中影响数据库性能的相关SQL语句记录到日志文件，通过对这些特殊的SQL语句分析，改进以达到提高数据库性能的目的。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;通过使用–slow_query_log[={0&lt;/td&gt;
          &lt;td&gt;1}]选项来启用慢查询日志。所有执行时间超过long_query_time秒的SQL语句都会被记录到慢查询日志。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;缺省情况下hostname-slow.log为慢查询日志文件安名，存放到数据目录，同时缺省情况下未开启慢查询日志。&lt;/li&gt;
  &lt;li&gt;缺省情况下数据库相关管理型SQL(比如OPTIMIZE TABLE、ANALYZE TABLE和ALTER TABLE)不会被记录到日志。&lt;/li&gt;
  &lt;li&gt;可以使用mysqldumpslow命令获得日志中显示的查询摘要来处理慢查询日志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何优化sql&quot;&gt;如何优化SQL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;加索引&lt;/li&gt;
  &lt;li&gt;避免返回不必要的数据&lt;/li&gt;
  &lt;li&gt;适当分批量返回&lt;/li&gt;
  &lt;li&gt;分库分表、读写分离&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wangbin</name></author><category term="计算机基础知识" /><summary type="html">事务的ACID特性</summary></entry><entry><title type="html">操作系统</title><link href="/OS/" rel="alternate" type="text/html" title="操作系统" /><published>2021-02-04T00:00:00+08:00</published><updated>2021-02-04T00:00:00+08:00</updated><id>/OS</id><content type="html" xml:base="/OS/">&lt;h2 id=&quot;进程线程协程&quot;&gt;进程、线程、协程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;进程是操作系统资源分配的最小单位，线程是cpu调度的最小单位。&lt;/li&gt;
  &lt;li&gt;进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。&lt;/li&gt;
  &lt;li&gt;一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。&lt;/li&gt;
  &lt;li&gt;进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。&lt;/li&gt;
  &lt;li&gt;进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。&lt;/li&gt;
  &lt;li&gt;和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。&lt;/li&gt;
  &lt;li&gt;协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。&lt;/li&gt;
  &lt;li&gt;协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。&lt;/li&gt;
  &lt;li&gt;协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。&lt;/li&gt;
  &lt;li&gt;一个进程可以包含多个线程，一个线程可以包含多个协程。&lt;/li&gt;
  &lt;li&gt;一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用 CPU 多核能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程拥有的资源&quot;&gt;进程拥有的资源&lt;/h2&gt;
&lt;p&gt;一个进程拥有独立的地址空间（代码段、数据段），打开的文件描述符、自身的信号处理器、所属用户id、进程控制块、进程id、一个或多个线程&lt;/p&gt;

&lt;h2 id=&quot;进程线程共享资源&quot;&gt;进程、线程共享资源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;父子进程共享资源：共享代码段，共享文件（具体而言是共享了文件偏移量）。全局变量、栈区、堆区不共享。
    &lt;ul&gt;
      &lt;li&gt;父子进程间的数据共享：读时共享，写时复制。&lt;/li&gt;
      &lt;li&gt;父子进程之间能够使用全局变量通信？不能，两个进程间内存不能共享。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同一进程间的线程共享的资源有：
    &lt;ul&gt;
      &lt;li&gt;堆：由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）&lt;/li&gt;
      &lt;li&gt;全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的&lt;/li&gt;
      &lt;li&gt;静态变量：虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的&lt;/li&gt;
      &lt;li&gt;文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;独享的资源有：栈、寄存器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程的调度算法&quot;&gt;进程的调度算法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;先来先去服务：按照请求的顺序进行调度&lt;/li&gt;
  &lt;li&gt;短作业优先：按估计运行时间最短的顺序进行调度&lt;/li&gt;
  &lt;li&gt;最短剩余时间优先：按剩余运行时间的顺序进行调度&lt;/li&gt;
  &lt;li&gt;时间片轮转法：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程&lt;/li&gt;
  &lt;li&gt;优先级调度：为每个进程分配一个优先级，按优先级进行调度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;虚拟内存换页的算法有哪些页面置换算法&quot;&gt;虚拟内存换页的算法有哪些？（页面置换算法）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_45-%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95&lt;/li&gt;
  &lt;li&gt;缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。&lt;/li&gt;
  &lt;li&gt;最近最少使用算法（LRU）：指维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾，优先淘汰表尾的页面。&lt;/li&gt;
  &lt;li&gt;最少频率使用算法（LFU）：它为每个页面设计了一个访问频次计数器，页面每次被访问时，频次加一，优先淘汰频次最小的页面。&lt;/li&gt;
  &lt;li&gt;先进先出算法（FIFO）：维护一个所有页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面，并把新页面加到表尾。缺点是有可能会将经常访问的页面淘汰。&lt;/li&gt;
  &lt;li&gt;最近未使用算法（NRU）：优先淘汰没有被访问的页面。&lt;/li&gt;
  &lt;li&gt;第二次机会算法：它对先进先出算法做了改进，当页面被访问时设置该页面的R（Read）位为1。需要替换时，检查最老页面的R位，如果为0，就表示这个页面又老又没有被使用，可以置换掉；如果为1，就将R位清0，并放到链表尾部。&lt;/li&gt;
  &lt;li&gt;时钟算法：第二次机会算法需要在链表中移动页面，降低了效率，时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。&lt;/li&gt;
  &lt;li&gt;最优算法：将最长时间内不再被访问的页面置换标记出来，然后把因调用这个页面而发生的缺页中断推迟到将来。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程几种状态状态转移&quot;&gt;进程几种状态，状态转移&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../image/进程状态切换.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;io模型&quot;&gt;IO模型&lt;/h2&gt;
&lt;p&gt;https://juejin.cn/post/6874898561985839118&lt;/p&gt;
&lt;h3 id=&quot;阻塞非阻塞同步异步&quot;&gt;阻塞、非阻塞、同步、异步&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回&lt;/li&gt;
  &lt;li&gt;非阻塞：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程&lt;/li&gt;
  &lt;li&gt;同步：指被调用方得到最终结果之后才返回给调用方&lt;/li&gt;
  &lt;li&gt;异步：指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方
    &lt;blockquote&gt;
      &lt;p&gt;阻塞、非阻塞的讨论对象是调用者；
同步、异步的讨论对象是被调用者。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5种io模型&quot;&gt;5种IO模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞 IO 模型：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/阻塞io模型.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;非阻塞IO模型：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/非阻塞io模型.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;IO 复用模型：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。（在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。）&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/io复用模型.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;信号驱动 IO 模型：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/信号驱动io模型.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;异步 IO 模型：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/异步io模型.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../image/5种io模型比较.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;selectpoll和epoll的区别&quot;&gt;select，poll和epoll的区别&lt;/h2&gt;

&lt;p&gt;https://juejin.cn/post/6844904174862204935&lt;/p&gt;
&lt;h3 id=&quot;区别&quot;&gt;区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;select()允许程序监视多个文件描述符，直到一个或多个文件描述符准备好进行某些类型的 I/O 操作。如果文件描述符可以不阻塞地执行相应的 I/O 操作(例如，read()或write())，则认为它已经准备好了。&lt;/li&gt;
  &lt;li&gt;poll 函数和 select 函数的功能类似，它等待一组 fd 中就绪的 I/O。&lt;/li&gt;
  &lt;li&gt;select，poll 是基于轮询实现的，将 fd_set 从用户空间复制到内核空间，然后让内核空间以 poll 机制来进行轮询，一旦有其中一个fd对应的设备活跃了，那么就把整个fd_set返回给客户端（复制到用户空间），再由客户端来轮询每个fd的，找出发生了IO事件的fd&lt;/li&gt;
  &lt;li&gt;epoll是基于事件驱动实现的，加入一个新的fd，会调用epoll_ctr函数为该fd注册一个回调函数，然后将该fd结点注册到内核中的epoll红黑树中，当IO事件发生时，就会调用回调函数，将该fd结点放到就绪链表中，epoll_wait函数实际上就是从这个就绪链表中获取这些fd。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;水平触发、边缘触发&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;水平触发的意思就是说，只要条件满足，对应的事件就会一直被触发。所以如果条件满足了但未进行处理，那么就会一直被通知&lt;/li&gt;
      &lt;li&gt;边缘触发的意思就是说，条件满足后，对应的事件只会被触发一次，无论是否被处理，都只会触发一次。&lt;/li&gt;
      &lt;li&gt;对于select和poll来说，其触发都是水平触发。而epoll则有两种模式：EPOLLLT（水平触发，默认状态）和EPOLLET（边缘触发，效率高）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;并不是所有的情况中epoll都是最好的，比如当fd数量比较小的时候，epoll不见得就一定比select和poll好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;select方法本质其实就是维护了一个文件描述符（fd）数组，以此为基础，实现IO多路复用的功能。这个fd数组有长度限制，在32位系统中，最大值为1024个，而在64位系统中，最大值为2048个。&lt;/li&gt;
  &lt;li&gt;poll维护了一个链表，所以从理论上，poll方法中，单个进程能监听的fd不再有数量限制&lt;/li&gt;
  &lt;li&gt;epoll_create会在内核建立一颗专门用来存放fd结点的红黑树&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程间通信&quot;&gt;进程间通信&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;管道 ( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。&lt;/li&gt;
  &lt;li&gt;有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。&lt;/li&gt;
  &lt;li&gt;信号量 ( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。&lt;/li&gt;
  &lt;li&gt;消息队列 ( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。&lt;/li&gt;
  &lt;li&gt;信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。&lt;/li&gt;
  &lt;li&gt;共享内存 ( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。&lt;/li&gt;
  &lt;li&gt;套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程间通信&quot;&gt;线程间通信&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；（每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源））&lt;/li&gt;
  &lt;li&gt;互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问&lt;/li&gt;
  &lt;li&gt;信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。&lt;/li&gt;
  &lt;li&gt;事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fork-系统调用&quot;&gt;fork 系统调用&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;作用：从已经存在的进程中创建一个子进程，原进程称为父进程。&lt;/li&gt;
  &lt;li&gt;调用 fork()，当控制转移到内核中的 fork 代码后，内核开始做：
    &lt;ul&gt;
      &lt;li&gt;分配新的内存块和内核数据结构给子进程。&lt;/li&gt;
      &lt;li&gt;将父进程部分数据结构内容拷贝至子进程。&lt;/li&gt;
      &lt;li&gt;将子进程添加到系统进程列表。&lt;/li&gt;
      &lt;li&gt;fork返回开始调度器，调度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;特点：
    &lt;ul&gt;
      &lt;li&gt;调用一次，返回两次并发执行&lt;/li&gt;
      &lt;li&gt;相同但是独立的地址空间&lt;/li&gt;
      &lt;li&gt;fork 的返回值：向父进程返回子进程的 pid，向子进程中返回 0，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fork 调用失败的原因
    &lt;ul&gt;
      &lt;li&gt;系统中有太多进程。&lt;/li&gt;
      &lt;li&gt;实际用户的进程数超过限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;僵尸进程孤儿进程守护进程&quot;&gt;僵尸进程、孤儿进程、守护进程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;孤儿进程&lt;/strong&gt;：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程并不会有什么危害&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;僵尸进程&lt;/strong&gt;：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
    &lt;ul&gt;
      &lt;li&gt;如果没有调用 wait/waitpid 的话，那么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所以我们应该避免僵尸进程&lt;/li&gt;
      &lt;li&gt;进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经 退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就 会一直阻塞在这里，直到有一个出现为止。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;守护进程&lt;/strong&gt;(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;物理内存和虚拟内存&quot;&gt;物理内存和虚拟内存&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;虚拟内存&quot;&gt;虚拟内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。&lt;/li&gt;
  &lt;li&gt;虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。&lt;/li&gt;
  &lt;li&gt;请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。&lt;/li&gt;
  &lt;li&gt;虚拟内存的好处：
    &lt;ul&gt;
      &lt;li&gt;1.扩大地址空间；&lt;/li&gt;
      &lt;li&gt;2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。&lt;/li&gt;
      &lt;li&gt;3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。&lt;/li&gt;
      &lt;li&gt;4.当进程通信时，可采用虚存共享的方式实现。&lt;/li&gt;
      &lt;li&gt;5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存&lt;/li&gt;
      &lt;li&gt;6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高&lt;/li&gt;
      &lt;li&gt;7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟内存的代价：
    &lt;ul&gt;
      &lt;li&gt;1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存&lt;/li&gt;
      &lt;li&gt;2.虚拟地址到物理地址的转换，增加了指令的执行时间。&lt;/li&gt;
      &lt;li&gt;3.页面的换入换出需要磁盘I/O，这是很耗时的&lt;/li&gt;
      &lt;li&gt;4.如果一页中只有一部分数据，会浪费内存。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分段和分页内存管理&quot;&gt;分段和分页、内存管理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;分段和分页共同点：
    &lt;ul&gt;
      &lt;li&gt;分页机制和分段机制都是为了提高内存利用率，减少内存碎片。&lt;/li&gt;
      &lt;li&gt;页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分段和分页区别
    &lt;ul&gt;
      &lt;li&gt;页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。&lt;/li&gt;
      &lt;li&gt;分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存管理方式：
    &lt;ul&gt;
      &lt;li&gt;块式管理：将内存分为几个固定大小的块，每个块中只包含一个进程。&lt;/li&gt;
      &lt;li&gt;页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。&lt;/li&gt;
      &lt;li&gt;段式管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，最重要的是段是有实际意义的，每个段定义了一组逻辑信息。 段式管理通过段表对应逻辑地址和物理地址。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。&lt;/li&gt;
      &lt;li&gt;段页式管理：段页式管理机制结合了段式管理和页式管理的优点。段页式管理机制就是把主存先分成若干段，每个段又分成若干页。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用户态和内核态区别&quot;&gt;用户态和内核态区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    &lt;ul&gt;
      &lt;li&gt;用户态(user mode)：用户态运行的进程或可以直接读取用户程序的数据。&lt;/li&gt;
      &lt;li&gt;内核态(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。&lt;/li&gt;
  &lt;li&gt;系统调用：与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。&lt;/li&gt;
  &lt;li&gt;系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。&lt;/li&gt;
  &lt;li&gt;用户态切换到内核态的几种方式
    &lt;ul&gt;
      &lt;li&gt;系统调用: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。&lt;/li&gt;
      &lt;li&gt;异常：当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。&lt;/li&gt;
      &lt;li&gt;硬件设备的中断: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux系统操作和命令&quot;&gt;Linux系统操作和命令&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;top命令&lt;/li&gt;
  &lt;li&gt;ps命令&lt;/li&gt;
  &lt;li&gt;netstat命令&lt;/li&gt;
  &lt;li&gt;awk命令&lt;/li&gt;
  &lt;li&gt;find命令&lt;/li&gt;
  &lt;li&gt;grep命令&lt;/li&gt;
  &lt;li&gt;wc命令&lt;/li&gt;
  &lt;li&gt;sed命令&lt;/li&gt;
  &lt;li&gt;head和tail命令&lt;/li&gt;
  &lt;li&gt;正则表达式&lt;/li&gt;
  &lt;li&gt;如何查找出现频率最高的100个IP地址&lt;/li&gt;
  &lt;li&gt;linux如何统计文件中某个字符串出现的频率&lt;/li&gt;
  &lt;li&gt;linux启动的第一个进程&lt;/li&gt;
  &lt;li&gt;linux查看端口占用&lt;/li&gt;
  &lt;li&gt;linux查看CPU和内存使用&lt;/li&gt;
  &lt;li&gt;Linux查看系统负载命令&lt;/li&gt;
  &lt;li&gt;Linux调试程序&lt;/li&gt;
  &lt;li&gt;Linux硬链接和软连接&lt;/li&gt;
  &lt;li&gt;core dump&lt;/li&gt;
  &lt;li&gt;cmake和makefile&lt;/li&gt;
  &lt;li&gt;Shell脚本基本语法和使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;硬链接和软链接&quot;&gt;硬链接和软链接&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;硬链接： 硬连接指通过索引节点 inode 来进行的连接，即每一个硬链接都是一个指向对应区域的文件。硬链接等于cp -p 加 同步更新。&lt;/li&gt;
  &lt;li&gt;软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块， 访问时替换自身路径。软链接可以理解成快捷方式。它和windows下的快捷方式的作用是一样的。&lt;/li&gt;
  &lt;li&gt;新建硬链接：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln 源文件 目标文件&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;新建软链接：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln -s 【目标目录】 【软链接地址】&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;修改软链接：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln -snf 【新目标目录】 【软链接地址】&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;死锁&quot;&gt;死锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。&lt;/li&gt;
  &lt;li&gt;死锁条件：1）互斥条件、2）请求和保持条件、3）不剥夺条件、4）环路等待条件&lt;/li&gt;
  &lt;li&gt;解决死锁的策略：
    &lt;ul&gt;
      &lt;li&gt;死锁预防：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如：
        &lt;ul&gt;
          &lt;li&gt;破坏保持和等待条件：一次性申请所有资源，之后不再申请资源，如果不满足资源条件则得不到资源分配。&lt;/li&gt;
          &lt;li&gt;破坏不可剥夺条件：当一个进程获得某个不可剥夺的资源时，提出新的资源申请，若不满足，则释放所有资源。&lt;/li&gt;
          &lt;li&gt;破坏循环等待条件：按某一顺序申请资源，释放资源则反序释放。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;死锁避免：进程在每次申请资源时判断这些操作是否安全。&lt;/li&gt;
      &lt;li&gt;死锁检测：判断系统是否属于死锁的状态，如果是，则执行死锁解除策略。&lt;/li&gt;
      &lt;li&gt;死锁解除：将某进程所占资源进行强制回收，然后分配给其他进程。（与死锁检测结合使用的）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;独享锁/共享锁(互斥锁/读写锁)：独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。共享锁：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::shared_lock&amp;lt;std::shared_mutex&amp;gt;&lt;/code&gt;，独享所：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_lock&amp;lt;std::shared_mutex&amp;gt;&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;乐观锁/悲观锁：
    &lt;ul&gt;
      &lt;li&gt;悲观锁：之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。&lt;/li&gt;
      &lt;li&gt;乐观锁：乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。&lt;/li&gt;
      &lt;li&gt;悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样 的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
```
#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;thread&gt;&lt;/thread&gt;&lt;/cassert&gt;&lt;/atomic&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;struct spinlock
{
    volatile std::atomic_flag lck;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spinlock(){
    lck.clear();
}

void lock(){
    while (std::atomic_flag_test_and_set_explicit(&amp;amp;lck, std::memory_order_acquire)){
        std::this_thread::yield();
    }
}

bool try_lock(){
    bool ret = !std::atomic_flag_test_and_set_explicit(&amp;amp;lck, std::memory_order_acquire);
    return ret;
}

void unlock(){
    std::atomic_flag_clear_explicit(&amp;amp;lck, std::memory_order_release);
} }; ```
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;正向代理反向代理&quot;&gt;正向代理、反向代理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;正向代理类似一个跳板机，代理访问外部资源。比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了&lt;/li&gt;
  &lt;li&gt;反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器&lt;/li&gt;
  &lt;li&gt;反向代理的作用：
    &lt;ul&gt;
      &lt;li&gt;保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网&lt;/li&gt;
      &lt;li&gt;负载均衡，通过反向代理服务器来优化网站的负载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端
反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;并发和并行&quot;&gt;并发和并行&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。&lt;/li&gt;
  &lt;li&gt;并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重点掌握&quot;&gt;重点掌握&lt;/h2&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缓存IO和直接IO&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程和线程的调度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消费者和生产者&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;推荐书籍&quot;&gt;推荐书籍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《深入理解计算机系统》很全面的书，这一本就够用了&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wangbin</name></author><category term="计算机基础知识" /><summary type="html">进程、线程、协程</summary></entry></feed>